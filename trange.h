// Copyright Â© Laura Andelare
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#pragma once

#include <memory>
#include <optional>
#include <ranges>
#include <span>
#include <utility>

// Use trange::view() to construct a view over any UE container or range, or
// use the pipe syntax to get a range satisfying STL and Ranges-v3:
// TArray<int> A;
// trange::view(A) | std::views::transform(...)
// A | trange::view | std::views::transform(...)

// elements_view, keys_view, values_view, etc. are not compatible with
// containers such as TMap because TTuple is not tuple-like as far as C++ is
// concerned. Use trange::elements, trange::keys, trange::values instead.

// Quick reference of commands (everything in namespace trange, everything
// callable as a function or usable as the RHS of operator|):

// view         Wrap a UE container or range to make it C++ range compatible
// elements<N>  Extract element N from a range of TTuples, with .Get<N>()
// keys         elements<0>
// values       elements<1>

namespace trange {
namespace detail {
template<typename...>
constexpr bool false_v = false;

template<typename T>
concept has_adl_span = requires(T t) { GetData(t); GetNum(t); };

template<typename T>
concept has_member_ue_iterator = requires(T t) { t.CreateConstIterator(); };

template<typename T>
concept has_adl_ue_iterator = requires(T t) { *begin(t); static_cast<bool>(begin(t)); ++begin(t); };

class end_sentinel {};

template<typename T>
auto get_ue_iterator(T&& in) requires has_member_ue_iterator<std::remove_reference_t<T>> {
  if constexpr (std::is_const_v<std::remove_reference_t<T>>)
    return in.CreateConstIterator();
  else
    return in.CreateIterator();
}

// Wraps a UE-style iterator
template<typename I>
class iterator {
  static constexpr bool has_index = requires(I it) { { it.GetIndex() } -> std::integral; };
  using iterator_t = std::conditional_t<std::default_initializable<I>, I, std::optional<I>>;

  iterator_t it;

  I& get() { return const_cast<I&>(std::as_const(*this).get()); }
  const I& get() const {
    if constexpr (std::is_same_v<I, iterator_t>)
      return it;
    else
      // This is not checked for validity: using a default-constructed iterator is invalid.
      return it.value();
  }

public:
  iterator() {}
  iterator(I&& iter) : it(std::move(iter)) {}
  iterator(const iterator& other) : it(other.it) {}
  iterator(iterator&& other) : it(std::move(other.it)) {}

  iterator& operator=(const iterator& other) {
    // UE iterators tend to not come with operator= but most UE containers
    // assume that everything can be memcpy'd around so... here it goes
    it.~iterator_t();
    ::new (&it) iterator_t(other.it);
    return *this;
  }

  bool operator==(end_sentinel) const { return !get(); }
  bool operator==(const iterator& other) const { return it == other.it; } // no get

  iterator& operator++() { return ++get(), *this; }
  iterator& operator--() { return --get(), *this; }
  iterator operator++(int) { return get()++; }
  iterator operator--(int) { return get()--; }
  iterator& operator+=(std::integral auto value) { return get() += value, *this; }
  iterator& operator-=(std::integral auto value) { return get() -= value, *this; }
  iterator operator+(std::integral auto value) const { return get() + value; }
  iterator operator-(std::integral auto value) const { return get() - value; }

  auto operator-(const iterator& other) const requires has_index {
    return get().GetIndex() - other.get().GetIndex();
  }

  decltype(auto) operator*() const { return get().operator*(); }
  decltype(auto) operator->() const { return get().operator->(); }

  using value_type = std::remove_reference_t<decltype(*std::declval<I>())>;
  using difference_type = decltype([] {
    if constexpr (has_index)
      return static_cast<I*>(nullptr)->GetIndex();
    else
      return 0LL;
  }());
};

// Wraps a UE class that has member CreateIterator()
template<typename T>
class member : public std::ranges::view_interface<member<T>> {
  using clean_t = std::remove_reference_t<T>;
  using ue_iterator_t = decltype(get_ue_iterator(std::declval<clean_t>()));
  using ue_const_iterator_t = decltype(get_ue_iterator(std::declval<const clean_t>()));

  T* in; // A reference would disable the default operator=

public:
  explicit member(T& in) : in(std::addressof(in)) {}

  iterator<ue_iterator_t> begin() { return get_ue_iterator(*in); }
  iterator<ue_const_iterator_t> begin() const { return get_ue_iterator(*in); }
  end_sentinel end() const { return {}; }
};

decltype(auto) adl_begin(auto&& in) { return begin(in); }

// Wraps a UE class that has ADL begin() returning a UE iterator
template<typename T>
class adl : public std::ranges::view_interface<adl<T>> {
  using clean_t = std::remove_reference_t<T>;
  using ue_iterator_t = decltype(adl_begin(std::declval<clean_t>()));
  using ue_const_iterator_t = decltype(adl_begin(std::declval<const clean_t>()));

  T* in; // A reference would disable the default operator=

public:
  explicit adl(T& in) : in(std::addressof(in)) {}

  iterator<ue_iterator_t> begin() { return adl_begin(*in); }
  iterator<ue_const_iterator_t> begin() const { return adl_begin(*in); }
  end_sentinel end() const { return {}; }
};

struct view_fn {
  template<typename T>
  auto operator()(T&& in) const {
    using clean_t = std::remove_reference_t<T>;
    if constexpr (std::ranges::range<clean_t>) // Already a range?
      return std::forward<T>(in);
    else if constexpr (has_adl_span<clean_t>)
      // std::span is cleaner than wrapping UE iterators if there's a GetData()
      return std::span(GetData(in), GetNum(in));
    else if constexpr (has_member_ue_iterator<clean_t>)
      return member(in);
    else if constexpr (has_adl_ue_iterator<clean_t>)
      return adl(in);
    else
      static_assert(false_v<T>, "No strategy to wrap this type");
  }

  template<typename T>
  friend auto operator|(T&& in, view_fn fn) { return fn(std::forward<T>(in)); }
};
}

constexpr detail::view_fn view;

template<size_t N>
constexpr auto elements = std::views::transform([](auto&& in) {
  return in.template Get<N>();
});
constexpr auto keys = elements<0>;
constexpr auto values = elements<1>;
}
